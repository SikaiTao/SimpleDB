# SimpleDB
Simple database implementation for assignment of NKU and its basic architecture goes from course CS186 of UCB
## 问题报告
### Lab 1
* __问题1:__ 在实现HeapPage.java中的isSlotUsed方法时，需要在header中判断某一位为0或1。问题在于，这里的成员变量为标头数组，即字节数组，无法高效地在数组中任意提取其中一个标头中的一位。  
* __解决方案:__ 利用计算机网络中掩码的思想，创建一个八位掩码，其中某一位（即想提取的对应位置）置1，其余位值0。将这个掩码与对应的header字节进行按位与的操作，按位与结果为0则该位为0，结果不为0则该位为1。  

* __问题2:__ 在实现HeapPage.java中的getNumEmptySlots方法时，需要在字节数组中按位计算0的个数，即循环取得每一字节计算其包含0的个数，之后累加即可。问题为如何找到一种高效的统计一个字节中0个数的算法。  
* __解决方案:__ 创建一个辅助函数countZero，输入参数为字节b，利用b&=b-1的核心算法进行实现，即在while循环中，每次进行b&b-1的操作并赋值，当b=0时停止，循环次数就是字节b中包含1的位的个数。用8减去这个数即为包含0的位的个数。这种算法性能和效率非常高。  

### Lab 2
* __问题1:__ 在实现聚合操作相关类时，即实现对应的数据库查询语句的“group by”关键字，这里所需要实现的最核心的类和函数为IntegerAggregator中的mergeTupleIntoGroup方法。但是遇到将会遇到一个问题：这个方法的输入值为一条元组t，无输出值，函数作用为更新聚合状态。即group by语句的底层实际上是动态地获取每一条元组，每获取一次更新聚合状态，而这个更新操作为“完备操作”——对于任意时刻的更新，当前的聚合状态均为这个时刻所获取的所有元组的最终聚合。而这里我们不能简单地采用“惰性操作”，即每获取一条元组t，都简单地保存这个元组，然后当聚合操作被调用获取结果集时，再相应地进行“average，max，min”等等操作，这种方法并不是最优的，因为首先我们需要时时刻刻保存所获取的所有元组，其次当多次调用获取结果集，将会进行多次重复计算操作。  
* __解决方案:__ mergeTupleIntoGroup获取每一个元组之后，都参与进行相关聚合操作的计算，更新内部状态之后即可丢弃该元组。需要实现的聚合操作有：sum、count、average、max和min五种，我们对应着建立四个哈希表：minMaxGroup、sumGroup、countGroup和averageGroup。它们的key为分组的字段gbfield，value为被聚合字段afield的状态值，例如平均值，最大/最小值等等。当一个新的元组t获取之后，先根据当前的操作装入不同的哈希表中，再判断这个哈希表是否预先含有这个元组的分组字段key，如是，则计算并更新value值（sum为叠加，min/max为比较更新，count为加一等等），反之则对于这个新的分组字段新建键值对。当调用获取结果集时，再将对应的哈希表转化为元组即可。  

* __问题2:__ 最后一个exercise需要实现Page Eviction策略，来使得当Page的缓存池存满之后，当新的一个Page读入时，将从缓存中寻找“最不常使用”的页，剔除它并置换成新的页。如何实现这个功能。  
* __解决方案:__ 类似于内存置换算法，我们将使用最简单但十分有效的LRU算法，在SimpleDB的BufferPool中实现，可以有三种代码编写方法：
  * 1)将页Page包装为一个新的对象，其中添加一个成员变量表示使用次数，每次被调用则次数加一，当置换时计算比较使用次数并选择次数最小的页。这种实现方法效率较低。
  * 2)新建一个链表作为BufferPool的Page容器来储存，当某一个Page被使用时，修改链表将它放在链表的尾部，则在每一时刻，此链表的头部是“最不常用”的页，进行Page置换时，将头部删去，并将新的Page置于尾部。
  * 3)Java.util.LinkedHashMap类已经实现了LRU算法，当初始化时令构造方法中的参数accessOrder为true时，则启用了LRU算法，当添加Page超过了其容量后，则自动置换最不常用的Page。  
__这里具体的代码实现使用了第三种方法。__


