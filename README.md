# SimpleDB
Simple database implementation for assignment of NKU and its basic architecture goes from course CS186 of UCB
## 问题报告
### Lab 1
* __问题1:__ 在实现HeapPage.java中的isSlotUsed方法时，需要在header中判断某一位为0或1。问题在于，这里的成员变量为标头数组，即字节数组，无法高效地在数组中任意提取其中一个标头中的一位。  
* __解决方案:__ 利用计算机网络中掩码的思想，创建一个八位掩码，其中某一位（即想提取的对应位置）置1，其余位值0。将这个掩码与对应的header字节进行按位与的操作，按位与结果为0则该位为0，结果不为0则该位为1。  

* __问题2:__ 在实现HeapPage.java中的getNumEmptySlots方法时，需要在字节数组中按位计算0的个数，即循环取得每一字节计算其包含0的个数，之后累加即可。问题为如何找到一种高效的统计一个字节中0个数的算法。  
* __解决方案:__ 创建一个辅助函数countZero，输入参数为字节b，利用b&=b-1的核心算法进行实现，即在while循环中，每次进行b&b-1的操作并赋值，当b=0时停止，循环次数就是字节b中包含1的位的个数。用8减去这个数即为包含0的位的个数。这种算法性能和效率非常高。  

### Lab 2
* __问题1:__ 在实现聚合操作相关类时，即实现对应的数据库查询语句的“group by”关键字，这里所需要实现的最核心的类和函数为IntegerAggregator中的mergeTupleIntoGroup方法。但是遇到将会遇到一个问题：这个方法的输入值为一条元组t，无输出值，函数作用为更新聚合状态。即group by语句的底层实际上是动态地获取每一条元组，每获取一次更新聚合状态，而这个更新操作为“完备操作”——对于任意时刻的更新，当前的聚合状态均为这个时刻所获取的所有元组的最终聚合。而这里我们不能简单地采用“惰性操作”，即每获取一条元组t，都简单地保存这个元组，然后当聚合操作被调用获取结果集时，再相应地进行“average，max，min”等等操作，这种方法并不是最优的，因为首先我们需要时时刻刻保存所获取的所有元组，其次当多次调用获取结果集，将会进行多次重复计算操作。  
* __解决方案:__ mergeTupleIntoGroup获取每一个元组之后，都参与进行相关聚合操作的计算，更新内部状态之后即可丢弃该元组。需要实现的聚合操作有：sum、count、average、max和min五种，我们对应着建立四个哈希表：minMaxGroup、sumGroup、countGroup和averageGroup。它们的key为分组的字段gbfield，value为被聚合字段afield的状态值，例如平均值，最大/最小值等等。当一个新的元组t获取之后，先根据当前的操作装入不同的哈希表中，再判断这个哈希表是否预先含有这个元组的分组字段key，如是，则计算并更新value值（sum为叠加，min/max为比较更新，count为加一等等），反之则对于这个新的分组字段新建键值对。当调用获取结果集时，再将对应的哈希表转化为元组即可。  

* __问题2:__ 最后一个exercise需要实现Page Eviction策略，来使得当Page的缓存池存满之后，当新的一个Page读入时，将从缓存中寻找“最不常使用”的页，剔除它并置换成新的页。如何实现这个功能。  
* __解决方案:__ 类似于内存置换算法，我们将使用最简单但十分有效的LRU算法，在SimpleDB的BufferPool中实现，可以有三种代码编写方法：
  * 1)将页Page包装为一个新的对象，其中添加一个成员变量表示使用次数，每次被调用则次数加一，当置换时计算比较使用次数并选择次数最小的页。这种实现方法效率较低。
  * 2)新建一个链表作为BufferPool的Page容器来储存，当某一个Page被使用时，修改链表将它放在链表的尾部，则在每一时刻，此链表的头部是“最不常用”的页，进行Page置换时，将头部删去，并将新的Page置于尾部。
  * 3)Java.util.LinkedHashMap类已经实现了LRU算法，当初始化时令构造方法中的参数accessOrder为true时，则启用了LRU算法，当添加Page超过了其容量后，则自动置换最不常用的Page。  
__这里具体的代码实现使用了第三种方法。__  

### Lab 3  
在Lab3中，难点主要为实现B+树增删功能的核心函数，其中插入功能需要实现的核心函数为__分裂__，删除功能需要实现的核心函数为__平衡分配__和__融合__。操作页面分为两种：__内部页__和__叶子页__。以下根据增删功能的核心函数与操作页面相对应可得到Lab3需要实现的6个功能，并且根据代码实现逻辑列出步骤：  
1. __叶子页分裂__
  * 创造空页面作为分裂产生的新页面
  * 找到被分裂页面中间位置的元组作为分裂点
  * 迭代从被分裂页面到新页面顺次转移元组，当转移停止时，新页面的第一个元组为分裂点
  * 将分裂前的旧页面的右兄弟变为新页面的右兄弟
  * 将分裂点中的key提取并包装成为新的entry（分别指向被分裂页面和新页面），将这个新的entry插入到父节点中（内部页）
  * 更新对应的父指针  
2. __内部页分裂__
  * 创造空页面作为分裂产生的新页面
  * 找到被分裂页面中间位置的entry作为分裂点
  * 迭代从被分裂页面到新页面顺次转移entry，当迭代碰到分裂点转移停止，即新页面不包含分裂点，新页面的第一个entry为分裂点后面临近的第一个entry
  * 将分裂点中的key提取并包装成为新的entry分别指向被分裂页面和新页面），将这个新的entry插入到父节点中
  * 更新对应的父指针
3. __叶子页平衡分配__  
  * 平衡分配实际上就是元组较少的页面从元组较多的页面进行元组的“偷取”，从而达到平衡效果  
  * 根据两个页面存有的元组数量计算它们达到平衡所需要转移的元组个数：[T(多)+T(少)]/2-T(少)
  * 迭代从元组较多的页面顺次向元组较少的页面转移元组，当达到平衡个数停止
  * 将平衡分配后的右页面中的第一个元组中的key复制到对应的父节点中的entry，进行更新。
4. __内部页平衡分配__  
  * 基本步骤与3基本相同，只将其中的元组概念变为entry，但是其中最重要的不同点在于，在循环迭代转移entry的第一层，需要将两个页面指向的父entry作为第一个被转移的对象。以从左转移到右为例，在循环第一次时需要将父entry删除，并添加到右页面中。而到循环的最后一次时，需要将从左页面拿到的entry直接转移到父节点作为新的父entry。除此之外，在上述操作中，还需要更新对应的指针
5. __叶子页融合__
  * 将右页面的元组顺次转移到左页面
  * 将右页面的右兄弟更新为融合后的左页面的右兄弟
  * 将右页面设置为空页面，便于以后重用
  * 删除父entry，但保留父entry左边的邻居entry的右指针，此右指针指向融合后的左页面 
6. __内部页融合__
  * 复制父entry的key值，包装成为新entry，设置新entry的左指针指向左页面的最后一个孩子，右指针指向右页面的第一个孩子，将新entry添加到左页面
  * 之后将右页面的entry顺次转移到左页面
  * 更新左页面中转移后的所有entry的指针
  * 将右页面设置为空页面，便于以后重用
  * 删除父entry，但保留父entry左边的邻居entry的右指针，此右指针指向融合后的左页面  




